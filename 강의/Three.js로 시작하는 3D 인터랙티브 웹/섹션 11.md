# 물리 엔진 다루기

## 물리엔진과 three.js의 관계
우리의 일상 생활에서의 물리 현상을 mesh는 가지고 있지 않다. <br>
하지만 Cannon.js의 body (눈에 보이지 않지만 위치와 회전점 등을 가지고 있음)는 물리현상을 가지고 있다. <br>
따라서 three.js의 mesh를 body의 행동을 따라하도록 연결해주면 mesh가 물리현상을 가지고 있는 것 처럼 행동하게 된다.

## 물리엔진 월드 생성
### Cannon.js
조금 오래된 패키지로 다운 받을 때 cannon-es 로 다운 받는 것을 권장 <br>
캐논에서의 월드는 물리 현상이 펼쳐질 공간으로 three.js에서의 scene과 비슷하다. <br>

```
const cannonWorld = new CANNON.World();
// 중력 셋팅 (중력 가속도 셋팅 가능)
// set으로 x,y,z축으로 설정 가능한데 중력이므로 z축만 해주면 된다.
cannonWorld.gravity.set(0, -10, 0);
```

cannon에서는 바닥이라는 개념이 없기 때문에 무게가 일단 주어지면 아래로 떨어지게 된다. <br>
따라서 바닥으로 쓸 plane의 mass는 0으로 지정해주어야 아래로 떨어지지 않는다.

### Contact Material
cannon.js에도 재질을 설정할 수 있다. 재질에 따라서 반발력, 마찰력 등이 달라지기 때문이다. <br>
접촉을 했을 때 어떻게 처리를 할 건지 만드는 게 컨택트 머티리얼이다. <br>
여러 종류의 머티리얼을 만들고 각 상황에 맞춰서 컨택트 부딪히는 것을 설정해주는 것이다. <br>
필요가 없다면 default와 default contactMaterial 만 설정해주고 다른 contactMaterial은 설정해주지 않아도 된다. <br>
contactMaterial을 설정해준 후에 등록하고 cannonWorld의 body에 재질을 추가해주는 과정이 필요하다.

```
// Contact Material
	const defaultMaterial = new CANNON.Material('default');
	const rubberMaterial = new CANNON.Material('rubber');
	const ironMaterial = new CANNON.Material('iron');
	const defaultContatctMaterial = new CANNON.ContactMaterial(
		defaultMaterial,
		defaultMaterial,
		// 마찰, 반발
		{
			friction: 0.5,
			restitution: 0.3
		}
	);
	// 얘를 캐논 월드에 디폴트 컨택트 머티리얼로 세팅해주어야한다.
	cannonWorld.defaultContactMaterial = defaultContatctMaterial;

	const rubberDefaultContactMaterial = new CANNON.ContactMaterial(
		rubberMaterial,
		defaultMaterial,
		{
			friction: 0.5,
			restitution: 0.7
		}
	);
	// 얘는 일단 등록많 해준 것이다.
	cannonWorld.addContactMaterial(rubberDefaultContactMaterial);

	const ironDefaultContactMaterial = new CANNON.ContactMaterial(
		ironMaterial,
		defaultMaterial,
		{
			friction: 0.5,
			restitution: 0
		}
	);
	// 얘는 일단 등록만 해준 것이다.
	cannonWorld.addContactMaterial(ironDefaultContactMaterial);


	const floorShape = new CANNON.Plane();
	// 물리엔진 적용될 곳 : 무게, 위치, 모양
	const floorBody = new CANNON.Body({
		mass: 0,
		position: new CANNON.Vec3(0, 0, 0),
		shape : floorShape,
		material: defaultMaterial
	});
	// three.js처럼 바닥이 서 있기 때문에 회전해주어야한다.
	floorBody.quaternion.setFromAxisAngle(
		new CANNON.Vec3(-1, 0, 0),
		Math.PI / 2
	)
	cannonWorld.addBody(floorBody);

	const sphereShape = new CANNON.Sphere(0.5, 5, 0.5);
	const sphereBody = new CANNON.Body({
		mass: 1,
		position: new CANNON.Vec3(0,10,0),
		shape: sphereShape,
		// material: rubberMaterial
		material: ironMaterial
	});
	cannonWorld.addBody(sphereBody);
```

### 힘 (Force)
물체의 위치에 영향을 주는 힘 추가

```
canvas.addEventListener('click', () => {
  // 힘을 벡터3의 형식으로 넣어주고 (왼쪽으로 -100만큼의 힘), 이 힘을 어디에 적용할건지 -> 즉 공의 위치
  // 거리가 길어지면 힘의 세기도 커진다. (벡터이기 때문에)
  sphereBody.applyForce(new CANNON.Vec3(-100, 0, 0), sphereBody.position );
});

    canvas.addEventListener('click', () => {
        if (preventDragClick.mouseMoved) return;

        // 힘을 벡터3의 형식으로 넣어주고 (왼쪽으로 -100만큼의 힘), 이 힘을 어디에 적용할건지 -> 즉 공의 위치
        // 이때 default로는 힘이 누적이 된다.
        sphereBody.velocity.x = 0;
        sphereBody.velocity.y = 0;
        sphereBody.velocity.z = 0;
        sphereBody.angularVelocity.x = 0;
        sphereBody.angularVelocity.y = 0;
        sphereBody.angularVelocity.z = 0;
        // 이렇게 해주면 클릭을 여러번해줘도 일정한 속도로 이동하게 된다.
        sphereBody.applyForce(new CANNON.Vec3(-500, 0, 0), sphereBody.position );
    });

// draw 함수 내
        sphereBody.velocity.x *= 0.98;
        sphereBody.velocity.y *= 0.98;
        sphereBody.velocity.z *= 0.98;
        sphereBody.angularVelocity.x *= 0.98;
        sphereBody.angularVelocity.y *= 0.98;
        sphereBody.angularVelocity.z *= 0.98;
```

### 랜덤 위치에 공 생성하기

### 성능 관리 설정

### 충돌 사운드 넣기

### 오브젝트 제거하기

### 도미노 만들기
